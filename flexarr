#!/bin/bash
# flexarr: a FlexVolume driver for CIFS or local direct mount
# version 0.2.1
# Copyright 2024 Chris Danis

# ‚ö†Ô∏è WARNING! ‚ö†Ô∏è
# ‚ò¢Ô∏è üò± DO NOT USE THIS PROGRAM. üò± ‚ò¢Ô∏è
# This program is not a program of honor.
#
# No highly esteemed function is executed here.
#
# What is here is dangerous and repulsive to us.
#
# The danger is still present, in your time, as it was in ours,
# without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is best shunned and left unused (but it is free software,
# and you are welcome to redistribute it under certain conditions).
# üò± ‚ò¢Ô∏è DO NOT USE THIS PROGRAM. ‚ò¢Ô∏è üò±
#
# This program is licensed under the Sandia Message Public License,
# sublicense GNU Affero General Public License version 3.0 (AGPL-3.0).
# This may be abbreviated as sandia-agpl-3.0.
# You may obtain a copy of the License(s) at
# https://github.com/cdanis/sandia-public-license/blob/main/LICENSE.md and
# https://www.gnu.org/licenses/agpl-3.0.html

set -e

# Function for logging
log() {
    logger -t flexarr "$1"
}

# Function for error handling
die() {
    local error_message="$1"
    log "FATAL: $error_message"
    echo "{\"status\": \"Failure\", \"message\": $(jq -Rs . <<< "$error_message")}"
    exit 1
}

# Function to execute command and capture output
run_or_die() {
    local output
    if ! output=$(eval "$1" 2>&1); then
        die "$output"
    fi
    log "$output"
}

# Function to check required commands
check_command() {
    if ! command -v "$1" &> /dev/null; then
        die "$1 is not installed"
    fi
}

# Function to safely decode base64
safe_decode() {
    echo "$1" | base64 --decode 2>/dev/null || die "Failed to decode $2"
}

# Main logic
case "$1" in
    init)
        check_command jq
        check_command mount.cifs
        check_command logger
        check_command mountpoint
        echo '{"status": "Success", "capabilities": {"attach": false}}'
        ;;
    mount)
        MOUNT_DIR=$2
        PARAMS=$3

        # Extract parameters
        NAS_HOSTNAME=$(jq -r '.nasHostname // empty' <<< "$PARAMS")
        NAS_LOCAL_PATH=$(jq -r '.nasLocalPath // empty' <<< "$PARAMS")
        NAS_NETWORK_PATH=$(jq -r '.nasNetworkPath // empty' <<< "$PARAMS")
        READ_ONLY=$(jq -r '.readOnly // "false"' <<< "$PARAMS")
        MOUNT_OPTIONS=$(jq -r '.mountOptions // ""' <<< "$PARAMS")
        FS_GROUP=$(jq -r '."kubernetes.io/mounterArgs.FsGroup" // empty' <<< "$PARAMS")
        FS_TYPE=$(jq -r '."kubernetes.io/fsType" // empty' <<< "$PARAMS")

        # Check required parameters
        [[ -z "$NAS_HOSTNAME" ]] && die "nasHostname is required"
        [[ -z "$NAS_LOCAL_PATH" ]] && die "nasLocalPath is required"
        [[ -z "$NAS_NETWORK_PATH" ]] && die "nasNetworkPath is required"
        [[ "$FS_TYPE" != "cifs" ]] && die "fsType must be 'cifs'"

        # Decode parameters from the secretRef
        USER=$(safe_decode "$(jq -r '."kubernetes.io/secret/username" // empty' <<< "$PARAMS")" "username")
        PASSWD=$(safe_decode "$(jq -r '."kubernetes.io/secret/password" // empty' <<< "$PARAMS")" "password")
        SECRET_OPTIONS=$(safe_decode "$(jq -r '."kubernetes.io/secret/mountOptions" // empty' <<< "$PARAMS")" "mountOptions")

        if [[ "$(hostname)" == "$NAS_HOSTNAME" ]]; then
            log "Performing local direct mount"
            run_or_die "mount --bind \"$NAS_LOCAL_PATH\" \"$MOUNT_DIR\""

            if [[ "$READ_ONLY" == "true" ]]; then
                run_or_die "mount -o remount,bind,ro \"$MOUNT_DIR\""
            fi
        else
            log "Performing CIFS mount"
            OPTIONS=("user=$USER" "password=$PASSWD")
            [[ "$READ_ONLY" == "true" ]] && OPTIONS+=("ro")
            [[ -n "$MOUNT_OPTIONS" ]] && OPTIONS+=("$MOUNT_OPTIONS")
            [[ -n "$SECRET_OPTIONS" ]] && OPTIONS+=("$SECRET_OPTIONS")
            [[ -n "$FS_GROUP" ]] && OPTIONS+=("gid=$FS_GROUP")

            run_or_die "mount -t cifs \"$NAS_NETWORK_PATH\" \"$MOUNT_DIR\" -o \"$(IFS=,; echo "${OPTIONS[*]}")\""
        fi

        log "Mount operation completed successfully"
        echo '{"status": "Success"}'
        ;;
    unmount)
        MOUNT_DIR=$2
        if mountpoint -q "$MOUNT_DIR"; then
            run_or_die "umount \"$MOUNT_DIR\""
            log "Unmount operation completed successfully"
        else
            log "Mount point $MOUNT_DIR is not mounted, skipping unmount"
        fi
        echo '{"status": "Success"}'
        ;;
    *)
        die "Not supported"
        ;;
esac
